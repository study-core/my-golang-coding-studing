package main

import (
	"fmt"
)

// https://zhuanlan.zhihu.com/p/91582909
func main() {
	num := climbGrid(4, 4)
	fmt.Println(num)
	num = climbGridOptimization(4, 4)
	fmt.Println(num)
}


// todo  爬格子


/**
一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。

问总共有多少条不同的路径？
 */

// m, n 分别为 格子矩阵的 m: 纵列 <行数> 和 n: 横行 <列数>
//
// O(n*m) 空间复杂度
func climbGrid(m, n int) int {

	if m <= 0 || n <= 0 {
		return 0
	}

	// 老规矩,  三步走

	// todo 步骤一：定义数组元素的含义
	//
	// 当机器人从左上角走到(i, j) 这个位置时，一共有 dp[i] [j] 种路径。那么，dp[m-1] [n-1] 就是我们要的答案了
	dp := make([][]int, m)
	for i := 0; i < m; i++ {
		item := make([]int, n)
		dp[i] = item
	}



	// todo 步骤二： 找出关系数组元素间的关系式  (状态方程)
	//
	// 由于机器人可以向下走或者向右走，所以有两种方式到达 (i, j)
	//
	//	一种是从 (i-1, j) 这个位置走一步到达   todo 往下走
	//
	//	一种是从(i, j - 1) 这个位置走一步到达  todo 往右走
	//
	// 因为是计算所有可能的步骤，所以是把所有可能走的路径都加起来，所以 todo 关系式是: `dp[i] [j] = dp[i-1] [j] + dp[i] [j-1]`


	// todo 步骤三：找出初始值  (最优子结构)

	/**
	显然，当 dp[i] [j] 中，如果 i 或者 j 有一个为 0，那么还能使用关系式吗？
	答是不能的，因为这个时候把 i - 1 或者 j - 1，就变成负数了，数组就会出问题了，
	todo 所以我们的初始值是计算出所有的 dp[0] [0….n-1] 和所有的 dp[0….m-1] [0]。
		这个还是非常容易计算的，相当于计算机图中的最上面一行和左边一列。因此初始值如下：

	dp[0] [0….n-1] = 1 (条路径);  相当于最上面一行，机器人只能一直往右走 todo 即 走到任意一格子都是 1条路线

	dp[0…m-1] [0] = 1 (条路径);   相当于最左面一列，机器人只能一直往下走 todo 即 走到任意一格子都是 1条路线
	 */


	// 初始化 (初始值)

	// 最左的一列 (各个格子只有往下走 一条路线)
	for i := 0; i < m; i++ {
		dp[i][0] = 1
	}
	// 最上一行 (各个格子只有往右走 一条路线)
	for i := 0; i < n; i++{
		dp[0][i] = 1
	}


	// 推导出 dp[m-1][n-1]
	for i := 1; i < m; i++ {    	// 往下遍历 格子
		for  j := 1; j < n; j++ {	// 往右遍历 格子
			dp[i][j] = dp[i-1][j] + dp[i][j-1]   // 状态转移
		}
	}
	return dp[m-1][n-1]

}




// O(n) 空间复杂度
func climbGridOptimization(m, n int) int {

	/**
	todo  我们先来回顾下 之前的 二维数组的矩阵

	_________________
	| 1 | 1 | 1 | 1 |    todo 填充 第一行时, 初始化 (最小子结构 之一)
	+---+---+---+---+
	|   |   |   |   |
	+---+---+---+---+
	|   |   |   |   |
	+---+---+---+---+
	|   |   |   |   |
	￣￣￣￣￣￣￣￣￣


	_________________
	| 1 | 1 | 1 | 1 |    todo 填充 第二行时, 因为状态方程:   dp[i][j] = dp[i-1][j] + dp[i][j-1]
	+---+---+---+---+
	| 1 | 2 | 3 | 4 |
	+---+---+---+---+
	|   |   |   |   |
	+---+---+---+---+
	|   |   |   |   |
	￣￣￣￣￣￣￣￣￣


	todo
		大家想一个问题，当我们要填充第三行的值的时候，我们需要用到第一行的值吗？
		答是不需要的，不行你试试，当你要填充第三，第四....第 n 行的时候，第一行的值永远不会用到，只要填充第二行的值时会用到第一行。

	todo
		根据公式 dp[i][j] = dp[i-1][j] + dp[i][j-1]，
	    我们可以知道，
		【当我们要计算第 i 行的值时，除了会用到第 i - 1 行外，其他第 1 至 第 i-2 行的值我们都是不需要用到的】
		也就是说，对于那部分用不到的值我们还有必要保存他们吗？

	todo
		答是没必要，我们只需要用一个一维的 dp[] 来保存一行的历史记录就可以了 (前 一行的历史数据)。
		然后在计算机的过程中，不断着更新 dp[] 的值。单说估计你可能不好理解，下面我就手把手来演示下这个过程。


	todo
		dp[n] 用来装 一维数据,  我们来一边填充第二行的值一边更新 dp[i] 的值，一边把第一行的值抛弃掉

		我们先来看看 之前二维时的一些规律

	_________________
	| 1 | 1 | 1 | 1 |    todo 填充 第一行时, 我们顺便将 对应的元素 追加到 dp[n] 中
	+---+---+---+---+
	|   |   |   |   |
	+---+---+---+---+
	|   |   |   |   |
	+---+---+---+---+
	|   |   |   |   |
	￣￣￣￣￣￣￣￣￣


	_________________
	|   | 1 | 1 | 1 |    todo 填充 第二行第一列时, 我们将 dp[0] 中原来 第一行第一列的元素更换为  第二行第一列的元素
	+---+---+---+---+
	| 1 |   |   |   |
	+---+---+---+---+
	|   |   |   |   |
	+---+---+---+---+
	|   |   |   |   |
	￣￣￣￣￣￣￣￣￣


	_________________
	|   | 1 | 1 | 1 |    todo 填充 第二行第二列时, 我们将 dp[1] 中原来 第一行第二列的元素更换为  第二行第二列的元素
	+---+---+---+---+
	| 1 | 2 |   |   |    todo 并且我们还发现了一个规律：
	+---+---+---+---+	 todo		以往的二维的时候， dp[i][j] = dp[i-1] [j]+ dp[i][j-1]。现在转化成一维，不就是 dp[i]<新的值> = dp[i]<旧的值> + dp[i-1] 吗？
	|   |   |   |   |
	+---+---+---+---+	 todo 即 dp[1] = dp[1] + dp[0]，而且还动态帮我们更新了 dp[1] 的值。
	|   |   |   |   |	 todo  因为刚开始 dp[i] 的保存第一行的值的，现在更新为保存第二行的值。
	￣￣￣￣￣￣￣￣￣


	_________________
	|   |   | 1 | 1 |    todo 即 dp[1]<新的值> = dp[1]<旧的值> + dp[0]，而且还动态帮我们更新了 dp[1] 的值。
	+---+---+---+---+    todo  因为刚开始 dp[i] 的保存第一行的值的，现在更新为保存第二行的值。
	| 1 | 2 |   |   |
	+---+---+---+---+
	|   |   |   |   |
	+---+---+---+---+
	|   |   |   |   |
	￣￣￣￣￣￣￣￣￣


	todo  由此 推出:  dp[i] = dp[i-1] + dp[i]
			dp[i-1] 相当于之前二维时的 dp[i-1][j]，dp[i]<旧值> 相当于之前二维时的 dp[i][j-1] ???
	todo 这个说反了吧 应该是  dp[i-1] 等于当前行的前一列, 即 原来二维的 dp[i][j-1], 而 dp[i]<旧值> 相当于 上一行的相同列, 即 原来二维的 dp[i-1][j]

	todo 最后 dp[n-1] 就是我们要求的结果了
	 */


	if m <= 0 || n <= 0 {
		return 0
	}

	dp := make([]int, n)  // 留 列数, 精简了 行数

	// 初始化   todo 第一行的所有数值
	for i := 0; i < n; i++ {
		dp[i] = 1
	}

	// 公式：dp[i] = dp[i-1] + dp[i]
	for i := 1; i < m; i++ {

		// 第 i 行第 0 列的初始值
		dp[0] = 1

		// 逐个更新 dp[i] 的值,  0 < i < n
		for j := 1; j < n; j++ {
			dp[j] = dp[j-1] + dp[j]
		}
	}
	return dp[n-1]



	return 0
}