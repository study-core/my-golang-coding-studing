package main

import "fmt"

// https://zhuanlan.zhihu.com/p/91582909
func main() {
	num := climbStairs(100)
	fmt.Println(num)
}


// TODO 爬楼梯

/**
一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法?
 */

// todo 动态规划，无非就是利用历史记录，来避免我们的重复计算。而这些历史记录，我们得需要一些变量来保存，一般是用一维数组或者二维数组来保存。

// 思路:
//
// todo 动态规划的三大步骤
//			一、 定义数组元素的含义
//			二、 找出数组元素之间的关系式   (状态方程式)
//			三、 找出初始值    (最优子结构)
//
//
// todo 本题：
//  	定义 dp[i] 的含义: 跳上一个 `i` 级的台阶总共有 `dp[i]` 种跳法
//		所以需要求出, dp[n] 就是我们要求的  n个台阶时 的跳法数量

//
// O(n) 空间复杂度
func climbStairs(n int) int { // n为 楼梯的阶数

	if n <= 1 {
		return n
	}

	// todo 步骤一：定义数组元素的含义
	//
	//先创建一个数组来保存历史数据  (保存 历史解法数量)
	dp := make([]int, n+1) // n+1 是因为, 当 n的取值为 0 -> n 而不是 1 -> n

	// todo 步骤二：对于这道题，由于情况可以选择跳一级，也可以选择跳两级，所以青蛙到达第 n 级的台阶有两种方式
	//
	//一种是从第 n-1 级跳上来
	//
	//一种是从第 n-2 级跳上来
	//
	//由于我们是要算所有可能的跳法的，所以有 todo  状态方程： dp[n] = dp[n-1] + dp[n-2]


	// todo 步骤三：给出初始值
	dp[0] = 0    // 当台阶数 n == 0时, 只有 0 种解法
	dp[1] = 1	 // 当台阶数 n == 1时, 只有 1 种解法
	dp[2] = 2    // 当台阶数 n == 1时, 只有 2 种解法
	// 我们再往前 试探下 n = 3时, 发现已经 符合 状态方程： dp[i] = dp[i-1] + dp[i-2] 了, 所以, n=3 不是初始值了

	// todo 通过关系式来计算出 dp[n]
	for i := 3; i <= n; i++ {
		dp[i] = dp[i-1] + dp[i-2]  // dp[i] 的所有解法数 == dp[i-1] + dp[i-2]
	}
	// 把最终结果返回
	return dp[n]
}


//  O( n) 空间复杂度优化成 O(1)
func climbStairsOptimization (n int) int {

	return 0
}