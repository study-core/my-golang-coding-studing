package main

import "fmt"

func main() {
	arr := [][]int{
		[]int{1, 3, 1},
		[]int{1, 5, 1},
		[]int{4, 2, 1},
	}
	count := climbGridMinRoad(arr)
	fmt.Println(count)
}


// todo 爬格子
//
// 给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的 [数字总和] 为最小。


/**

举例：
输入:
arr = [
  [1,3,1],
  [1,5,1],
  [4,2,1]
]
输出: 7
解释: 因为路径 1→3→1→1→1 的总和最小.

 */

// O(n*m) 空间复杂度
func climbGridMinRoad(arr [][]int) int {

	m := len(arr) 		// m: 行数
	n := len(arr[0]) 	// n: 列数
	if m <= 0 || n <= 0 {
		return 0
	}

	// 老规矩， 三步走

	// todo 步骤一：定义数组元素的含义

	// 由于我们的目的是从左上角到右下角，最小路径和是多少，那我们就定义 dp[i] [j]的含义为：
	// 当机器人从左上角走到(i, j) 这个位置时，最下的路径和是 dp[i] [j]。那么，dp[m-1] [n-1] 就是我们要的答案了.
	dp := make([][]int, m)
	for i := 0; i < m; i++ {
		item := make([]int, n)
		dp[i] = item
	}


	// todo  步骤二: 找出关系数组元素间的关系式  (状态方程)

	/**
	todo 机器人要怎么样才能到达 (i, j) 这个位置？

	todo 由于机器人可以向下走或者向右走，所以有两种方式到达.

	一种是从 (i-1, j) 这个位置走一步到达

	一种是从(i, j - 1) 这个位置走一步到达

	todo 不过这次不是计算所有可能路径，而是计算哪一个路径和是最小的，
		那么我们要从这两种方式中，
		选择一种，使得dp[i] [j] 的值是最小的，显然有.

	todo dp[i] [j] = min(dp[i-1][j], dp[i][j-1]) + arr[i][j];     (arr[i][j] 表示网格 中的值)

	 */


	// todo 步骤三：找出初始值  (最优子结构)

	/**
	todo 显然，当 dp[i] [j] 中，如果 i 或者 j 有一个为 0，那么还能使用关系式吗？
		答是不能的，因为这个时候把 i - 1 或者 j - 1，就变成负数了，数组就会出问题了，

	todo 所以我们的初始值是计算出所有的 dp[0] [0….n-1] 和所有的 dp[0….m-1] [0]。
		这个还是非常容易计算的，相当于计算机图中的 【最上面一行】 和 【左边一列】。因此初始值如下：

	dp[0] [j] = arr[0] [j] + dp[0] [j-1];   todo 相当于最上面一行，机器人只能一直往右走

	dp[i] [0] = arr[i] [0] + dp[i-1] [0];     todo 相当于最左面一列，机器人只能一直往下走
	 */


	// 初始化 (初始值)

	//  0点的值
	dp[0][0] = arr[0][0]

	// 初始化最左边的列
	for i := 1; i < m; i++ {
		dp[i][0] = dp[i-1][0] + arr[i][0]
	}
	// 初始化最上边的行
	for j := 1; j < n; j++ {
		dp[0][j] = dp[0][j-1] + arr[0][j]
	}

	minFn := func(a, b int) int {
		if a < b {
			return a
		}
		return b
	}

	// 推导出 dp[m-1][n-1]
	for i := 1; i < m; i++  {                 	// 逐行遍历
		for j := 1; j < n; j++ {	      		// 逐列遍历
			dp[i][j] = minFn(dp[i-1][j], dp[i][j-1]) + arr[i][j]
		}
	}
	return dp[m-1][n-1]
}


