package main


// K-d 树  (K 维查找树)  2-d   3-d  4-d 等等
func main() {

}


/**
如何建立KD-Tree

1. 建立根节点；

2. 选取方差最大的特征作为分割特征；  todo 为什么方差最大的适合作为特征呢？   	因为方差大，数据相对“分散”，选取该特征来对数据集进行分割，数据散得更“开”一些。

3. 选择该特征的中位数作为分割点；    todo 为什么选择中位数作为分割点呢？ 		因为借鉴了BST，选取中位数，让左子树和右子树的数据数量一致，便于二分查找。

4. 将数据集中该特征小于中位数的传递给根节点的左儿子，大于中位数的传递给根节点的右儿子；

5. 递归执行步骤2-4，直到所有数据都被建立到KD Tree的节点上为止。

不难看出，KD Tree的建立步骤跟BST是非常相似的，可以认为BST是KD Tree在一维数据上的特例。KD Tree的算法复杂度介于O(Log2(N))和O(N)之间
 */