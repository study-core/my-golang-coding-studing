// 下面两种方式
// 目前可能遇到的函数标志有NOSPLIT、WRAPPER和NEEDCTXT几个。
// 【NOSPLIT】不会生成或包含栈分裂代码，这一般用于没有任何其它函数调用的叶子函数，这样可以适当提高性能。
// 【WRAPPER】标志则表示这个是一个包装函数，在panic或runtime.caller等某些处理函数帧的地方不会增加函数帧计数。
// 【NEEDCTXT】表示需要一个上下文参数，一般用于闭包函数。



//
//  需要注意的是函数也没有类型，这里定义的Swap函数签名可以下面任意一种格式：
//
//  func Swap(a, b, c int) int
//  func Swap(a, b, c, d int)
//  func Swap() (a, b, c, d int)
//  func Swap() (a []int, d int)
//  // ...
//
//  注意： 对于汇编函数来说，只要是函数的名字和参数大小一致就可以是相同的函数了。
//  而且在Go汇编语言中，输入参数和返回值参数是没有任何的区别的。



// func Swap(a, b int) (int, int)
//
// 这是 完整写法， 函数名部分包含了当前包的路径，同时指明了函数的参数大小为32个字节（对应参数和返回值的4个int类型）。
#include "textflag.h"
TEXT ·GavinSwap(SB), NOSPLIT, $0-32 // 这里写 0-32 或者 0 都是可以的，因为go 的编译器会自动根据类型判断内存占用大小
    MOVQ a+0(FP), AX     // AX = a  这里是把a的值移动到 AX
    MOVQ b+8(FP), BX     // BX = b  这里把b的值移动到 BX
    MOVQ BX, ret0+16(FP) // ret0 = BX  这里把 BX的值移动到 ret0 中
    MOVQ AX, ret1+24(FP) // ret1 = AX  这里把 AX的值移动到 ret1 中
    RET // 这个只是代表函数结束了
// func Swap(a, b int) (int, int)
//
// 这是 简洁写法， 省略了当前包的路径和参数的大小。如果有NOSPLIT标注，会禁止汇编器为汇编函数插入栈分裂的代码 (即： 溢出时，做分裂栈拓展)。NOSPLIT对应Go语言中的//go:nosplit注释。
// TEXT ·Swap(SB), NOSPLIT, $0


//
//  对于： func Foo(a bool, b int16) (c []byte)
//
//   栈中的分布情况， (FP： 中记录的是当前函数栈帧的地址)
//
//   c.Cap (64bit) -------------  c+24(FP)
//   c.Len (64bit) -------------  c+16(FP)
//   c.Data(64bit) -------------  c+8(FP)
//   a(8bit)--(8bit)--b(16bit)--(32bit)  -------------- 0(FP)
//      |                 |
//      |                 |
//     a+0(FP)           b+2(FP)
//
//  从上面可以看出，其中a和b参数之间出现了一个字节的空洞，b和c之间出现了4个字节的空洞。
//  出现空洞的原因是要保证每个参数变量地址都要对齐到相应的倍数。
//
//
//TEXT ·Foo(SB), $0        // 注意 伪寄存器不是真的寄存器，它一直指向当前最新的函数栈帧！
//    MOVEQ a+0(FP),       AX // a    // 这句的意思是，去 FP中前一个byte中的值一道 AX中
//    MOVEQ b+2(FP),       BX // b
//    MOVEQ c_dat+8*1(FP), CX // c.Data
//    MOVEQ c_len+8*2(FP), DX // c.Len
//    MOVEQ c_cap+8*3(FP), DI // c.Cap
//    RET



/// 函数的局部变量
//
// Go汇编语言引入了伪SP寄存器，对应当前栈帧的底部
// 因为在当前(函数)栈帧时栈的底部是固定不变的，因此局部变量的相对于伪SP的偏移量也就是固定的，这可以简化局部变量的维护工作。
//
//
//
//
//  func Foo() {
//      var c []byte
//      var b int16
//      var a bool
//  }
//
//
// 在X86平台，函数的调用栈是从高地址向低地址增长的。
//
// 因此伪SP寄存器对应栈帧的底部其实是对应更大的地址。
//
// 当前栈的顶部对应真实存在的SP寄存器，对应当前函数栈帧的栈顶，对应更小的地址。
//
// 如果整个内存用Memory数组表示:
// 那么Memory[0(SP):end-0(SP)]就是对应当前栈帧的切片，
// 其中开始位置是真SP寄存器，结尾部分是伪SP寄存器。
// 真SP寄存器一般用于表示调用其它函数时的参数和返回值，
// 真SP寄存器对应内存较低的地址，所以被访问变量的偏移量是正数；
// 而伪SP寄存器对应高地址，对应的局部变量的偏移量都是负数。
//
//
// 使用 伪寄存器 SP 来定位 局部变量
//
//
//
//  TEXT ·Foo(SB), $32-0
//      MOVQ a-32(SP),      AX // a
//      MOVQ b-30(SP),      BX // b
//      MOVQ c_data-24(SP), CX // c.Data
//      MOVQ c_len-16(SP),  DX // c.Len
//      MOVQ c_cap-8(SP),   DI // c.Cap
//      RET
//
//
//  Foo函数有3个局部变量，但是没有调用其它的函数，
//  因为对齐和填充的问题导致函数的栈帧大小为32个字节。
//  因为Foo函数没有参数和返回值，因此参数和返回值大小为0个字节，
//  当然这个部分可以省略不写。
//
//  而局部变量中先定义的变量c离伪SP寄存器对应的地址最近，
//  最后定义的变量a离伪SP寄存器最远。
//
//  有两个因素导致出现这种逆序的结果：
//
//  一个从Go语言函数角度理解，先定义的c变量地址要比后定义的变量的地址更大；
//
//  另一个是伪SP寄存器对应栈帧的底部，而X86中栈是从高向低生长的，
//  所以最先定义有着更大地址的c变量离栈的底部伪SP更近。
//
//
//



// 伪寄存器 FP 和 SP 的区别
//
// 参数和返回值是通过伪FP寄存器定位的，
// FP寄存器对应第一个参数的开始地址（第一个参数地址较低），
// 因此每个变量的偏移量是正数。
//
// 而局部变量是通过伪SP寄存器定位的，
// 而伪SP寄存器对应的是第一个局部变量的结束地址（第一个局部变量地址较大），
// 因此每个局部变量的偏移量都是负数。
//
//
//
//
//
//
//



// 使用 宏函数 定义 交换函数
//
#define GavinSwapMacro(x, y, t) MOVQ x, t; MOVQ y, x; MOVQ t, y

// 使用汇编引用 宏函数
// func Swap(a, b int) (int, int)
TEXT ·GavinSwap2(SB), $0-32
    MOVQ a+0(FP), AX // AX = a
    MOVQ b+8(FP), BX // BX = b

    GavinSwapMacro(AX, BX, CX)     // AX, BX = b, a  // 这里使用宏函数

    MOVQ AX, ret0+16(FP) // return
    MOVQ BX, ret1+24(FP) //
    RET
